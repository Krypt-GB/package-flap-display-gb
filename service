#!/usr/bin/python

import time
import textwrap
import sys

try:
    import urllib2 as urllib
except ImportError:
    import urllib.request as urllib

from ibquery import InfoBeamerQuery

ICAL_URL = "https://calendar.google.com/calendar/ical/55482e085e715a1d26cc4a40b330928113e9c7f252fa25d9c6b4138e735d94cd%40group.calendar.google.com/public/basic.ics"

def get_todays_calendar_entries():
    try:
        print("Fetching calendar data...")
        response = urllib.urlopen(ICAL_URL)
        data = response.read().decode('utf-8')
        
        today_str = time.strftime("%Y%m%d")
        events = data.split("BEGIN:VEVENT")
        found_entries = []

        for event in events:
            if ("DTSTART;VALUE=DATE:" + today_str in event) or ("DTSTART:" + today_str in event):
                for line in event.splitlines():
                    if line.startswith("SUMMARY:"):
                        entry_name = line.replace("SUMMARY:", "").strip()
                        if entry_name:
                            found_entries.append(entry_name.upper())
        
        return found_entries if found_entries else ["NO ENTRIES PLANNED"]

    except Exception as e:
        print("Error fetching calendar: %s" % e)
        return ["CALENDAR ERROR"]

def main():
    WIDTH = 25 
    while 1:
        try:
            ib = InfoBeamerQuery("127.0.0.1")
            
            entries = get_todays_calendar_entries()
            today_date = time.strftime("%A %d-%m-%Y")

            # 1. Build the list of rows
            # Row 1: Empty (for padding)
            # Row 2: Date
            # Row 3: Empty
            all_rows = ["", today_date, ""]
            
            for item in entries:
                wrapped_item = textwrap.wrap(item, width=WIDTH)
                for line in wrapped_item:
                    all_rows.append(line)
                # Add one empty row between entries to distinguish them
                all_rows.append("")

            # 2. Open connection to 'atomic'
            con = ib.node("display/atomic").io(raw=True)
            
            # 3. Write each line one by one
            # The Lua script will collect these in session.lines
            for row in all_rows:
                con.write(row + "\n")
            
            # 4. Closing the connection triggers the 'disconnect' event in Lua
            # which clears the screen and appends all collected lines.
            con.close()
            
            print("Successfully sent %d entries" % len(entries))

        except Exception as e:
            print("Main loop error: %s" % e)

        time.sleep(60)

if __name__ == "__main__":
    main()
