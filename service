#!/usr/bin/python3

# Info-Beamer service to fetch a private Google Calendar ICS
# and display next 5 events on the flap display.

import time
import requests
from datetime import datetime, timezone

# Your private ICS URL
CAL_URL = "https://calendar.google.com/calendar/ical/55482e085e715a1d26cc4a40b330928113e9c7f252fa25d9c6b4138e735d94cd%40group.calendar.google.com/private-c15a39ea7a68d0ab6bde810dddd34645/basic.ics"

MAX_EVENTS = 5

from ibquery import InfoBeamerQuery

def fetch_next_events():
    try:
        r = requests.get(CAL_URL)
        r.raise_for_status()
        data = r.text.splitlines()
    except Exception as e:
        return ["Error fetching calendar: %s" % e]

    events = []
    current_event = {}
    for line in data:
        line = line.strip()
        if line == "BEGIN:VEVENT":
            current_event = {}
        elif line.startswith("SUMMARY:"):
            current_event["summary"] = line[len("SUMMARY:"):].strip()
        elif line.startswith("DTSTART"):
            # parse datetime like 20260115T140000Z
            dt = line.split(":")[1]
            try:
                current_event["start"] = datetime.strptime(dt, "%Y%m%dT%H%M%SZ").replace(tzinfo=timezone.utc)
            except:
                current_event["start"] = None
        elif line == "END:VEVENT":
            if "summary" in current_event and "start" in current_event:
                if current_event["start"] > datetime.now(timezone.utc):
                    events.append(current_event)
            current_event = {}

    # sort by start date
    events.sort(key=lambda x: x["start"])
    # only take first MAX_EVENTS
    events = events[:MAX_EVENTS]

    # convert to text lines: "HH:MM Event Summary"
    lines = []
    for ev in events:
        local_time = ev["start"].astimezone()
        lines.append("%02d:%02d %s" % (local_time.hour, local_time.minute, ev["summary"]))
    if not lines:
        lines = ["No upcoming events"]
    return lines

def main():
    while True:
        ib = InfoBeamerQuery("127.0.0.1")
        con = ib.node("display/atomic").io(raw=True)

        events_lines = fetch_next_events()

        # write each line to the display
        for line in events_lines:
            con.write(line + "\n")

        con.close()
        # update every 60 seconds
        time.sleep(60)

if __name__ == "__main__":
    main()
